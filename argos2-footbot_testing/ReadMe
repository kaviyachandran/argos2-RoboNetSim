When there are more number of agents, goal positions can be distinguished by id. store in map with id -> key, struct-> valuev

To DO:

change randomwaypoint -> mission agent (size add it to xml)

In relay controller restrict the spiral motion to a certain time limit.-> Total time for a run / Number of agents assigned to a relay

Draw sequence diagram, state  transition diagram

Collect data and plot


time limit = 3*time taken to cover the diagonal

time for each agent = [time limit - time taken to cover the diagonal(this is done to consider the time to go back to base station)]/					   No of agent

 What if I make the relays only explore the environment. They will collect the data from agents when they meet on the way. I need to coordinate the relays so that they dont explore the same region as some other relay.


 Idea :

 Use Q-learning to learn a particular quadrant as important based on the number of agents it met in a quadrant

 Limitation:

 Disk model assumed is not accurate


 06/02 -> When there are more than one base station make base station pos as map with number as key and pos -> value
 07/02 - State Machine:

 1-1-1 case:

 Search state -> Data Gather ---- When an agent is detected
 Data Gather -> Search State ----- If the agent's data size is zero

 Data Gather -> Return ------- When data is gathered from agent
 Return -> State Search ----- Once data is transferred to Base Station

 Experiment 1:

 10 runs with BS Pos = -4.3,-4.3
 Agent : x="2.0" y="-4.0"

 Experiment 2:

 10 runs with BS Pos = 0,0
 Agent : x="2.0" y="-4.0"


 import pickle

with open('outfile', 'wb') as fp:
    pickle.dump(itemlist, fp)
To read it back:

with open ('outfile', 'rb') as fp:
    itemlist = pickle.load(fp)


check distance calculated in spiral.cpp

Command to execute eigen files :
g++ -std=c++11 -I/usr/include/eigen3 first_eigen.cpp -o my_exec

Random Number:

srand(time(0));
int r = rand() % (20 - 10) + 10;
If you want to include 20 in the range then this is a range of 11 numbers:

int r = rand() % (21 - 10) + 10


Probability of either one of the random events occurring : 

P(A or B) = P(A) + P(B) - P(A intersection B) (Remember the venn diagram)

Sum(d_mat) = 1 
but b_vector =/ 1
